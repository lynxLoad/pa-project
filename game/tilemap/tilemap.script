

local tilemap_data = require("game.tilemap.tilemap")
local entity = require("game.entity.entity")

local Map = require("game.tilemap.autotiling.autotiling")

local walls = Map:new()
local plan = Map:new()
local created_tiles = {}
local drag_state = {
	is_drag = false,
	to_delete = false,
	start = {x = 0, y = 0},
	last_tile = {x = 0, y = 0}
}
local reversed_plan = (function ()
	local reversed = {}
	for mask, id in pairs(require("game.tilemap.autotiling.bitmask_map").plan) do
		reversed[id] = mask
	end
	return reversed
end)()

function init(self)
	msg.post(".", "acquire_input_focus")
	
	math.randomseed(os.time())

	local _, _, w, h = tilemap.get_bounds("#tilemap")
	walls:init("walls", tilemap.get_tiles("#tilemap", "walls"), w, h)
	plan:init("plan", tilemap.get_tiles("#tilemap", "plan"), w, h)
	tilemap_data.width, tilemap_data.height = w, h

	local grass_tiles = {35,36,44,45,53,54}
	for y=1, h do
		for x=1, w do
			local grass_chance = math.random()
			if grass_chance < .1 then
				local flip = math.random()
				if flip < .5 then
					tilemap.set_tile("#tilemap", "ground", x, y, grass_tiles[math.random(#grass_tiles)], tilemap.H_FLIP)
				else
					tilemap.set_tile("#tilemap", "ground", x, y, grass_tiles[math.random(#grass_tiles)])
				end
			else
				tilemap.set_tile("#tilemap", "ground", x, y, 27)
			end
			table.insert(tilemap_data.astar_map, 0)
		end
	end
	setup_astar()
end

function on_input(self, action_id, action)
	local mouse_button_left = action_id == hash("mouse_button_left")
	local mouse_button_right = action_id == hash("mouse_button_right")
	local world = vmath.screen_to_world(action.x, action.y, 0, camera.get_projection(entity.camera.component), camera.get_view(entity.camera.component))

	local x, y = world.x, world.y
	local tile_x, tile_y = tilemap.world_to_tile(x, y, tilemap_data.tile_size)

	-- Обработка отпускания кнопки мыши
	if drag_state.is_drag then
		-- Завершаем перетаскивание и создаем регион
		create_region(plan, "plan", "plan", drag_state.start, {x = tile_x, y = tile_y})
	end

	-- Обработка нажатия кнопки мыши
	if mouse_button_left then
		if action.pressed then
			drag_state.is_drag = true
			drag_state.start.x = tile_x
			drag_state.start.y = tile_y
			drag_state.last_tile.x = tile_x
			drag_state.last_tile.y = tile_y
		end
		if action.released then
			drag_state.is_drag = false
			created_tiles = {}
		end
	end
end

function new_tile(map, tileset, layer, x, y, update_astar)
	local updated_tiles = map:new_tile(tileset, x, y)

	for _, ut in ipairs(updated_tiles) do
		tilemap.set_tile("#tilemap", layer, ut.x, ut.y, ut.tile_id)

		if update_astar == true then
			local index = coord_to_index(ut.x, ut.y, tilemap_data.width)
			tilemap_data.astar_map[index] = 1
			astar.set_map(tilemap_data.astar_map, 0)
		end
	end
end

function remove_tile(map, tileset, layer, x, y, update_astar)
	local updated_tiles = map:remove_tile(tileset, x, y)
	tilemap.set_tile("#tilemap", layer, x, y, 0)

	for _, ut in ipairs(updated_tiles) do
		tilemap.set_tile("#tilemap", layer, ut.x, ut.y, ut.tile_id)

		if update_astar == true then
			local index = coord_to_index(ut.x, ut.y, tilemap_data.width)
			tilemap_data.astar_map[index] = 0
			astar.set_map(tilemap_data.astar_map, 0)
		end
	end
end

function coord_to_index(x, y, width) return (y - 1) * width + x end

local function get_rect_border(start_point, end_point)
	return
	math.min(start_point.y, end_point.y),  -- start_y
	math.max(start_point.y, end_point.y),  -- end_y
	math.min(start_point.x, end_point.x),  -- start_x
	math.max(start_point.x, end_point.x)   -- end_x
end

local function key(x, y)
	return y .. ":" .. x
end

-- Обёртка для создания тайла, чтобы отслеживать его
local function tracked_new_tile(map, tileset, layer, x, y)
	created_tiles[key(x, y)] = true
	new_tile(map, tileset, layer, x, y, true)
end

-- Обёртка для удаления тайла
local function tracked_remove_tile(map, tileset, layer, x, y)
	created_tiles[key(x, y)] = nil
	remove_tile(map, tileset, layer, x, y)
end

function create_region(map, tileset, layer, start_point, end_point)
	local start_y, end_y, start_x, end_x = get_rect_border(start_point, end_point)

	-- 1. Создаём новую границу
	for x = start_x, end_x do
		for y = start_y, end_y do
			local is_border = (x == start_x or x == end_x or y == start_y or y == end_y)

			if is_border then
				if map.map.data[y] and map.map.data[y][x] and map.map.data[y][x] == -1 then
					tracked_new_tile(map, tileset, layer, x, y)
				end
			end
		end
	end

	-- 2. Удаляем старые тайлы, которые не подходят под новую границу
	for k, _ in pairs(created_tiles) do
		local y, x = k:match("^(%d+):(%d+)$")
		x = tonumber(x)
		y = tonumber(y)

		-- Повторная проверка
		local inside = (x >= start_x and x <= end_x and y >= start_y and y <= end_y)
		local border = (x == start_x or x == end_x or y == start_y or y == end_y)

		if not (inside and border) then
			tracked_remove_tile(map, tileset, layer, x, y)
		end
	end
end

function setup_astar()
	-- Настройка A*
	local direction = astar.DIRECTION_EIGHT -- 8 направлений
	local allocate = tilemap_data.width * tilemap_data.height
	local typical_adjacent = 8
	local cache = true  -- Optional. Default is true
	local use_zero = false -- Optional. Default is false = 1 based
	local flip_map = false -- Optional. Default is false
	local costs = {
		[0] = {1,1,1,1,
		1.01,1.01,1.01,1.01},
	}
	astar.new_map_id() -- 0
	astar.setup(tilemap_data.width, tilemap_data.height, direction, allocate, typical_adjacent, cache, use_zero, flip_map, 0)
	astar.set_map(tilemap_data.astar_map, 0)
	astar.set_costs(costs, 0)
end

