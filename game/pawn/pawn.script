go.property("start_position", vmath.vector3(1, 1, 0))

local map_config = require("game.tilemap.map_config")

local tile_size = map_config.tile_size

function init(self)
	self.position = vmath.vector3(0,0,0)
	self.current_path = {}
	self.is_target = false

	local spx, spy = tilemap.tile_to_world(self.start_position.x, self.start_position.y)
	go.set_position(vmath.vector3(spx, spy, self.start_position.z))
	msg.post(map_config.tilemap_path, "send_pawn", { x = self.start_position.x, y = self.start_position.y })

	msg.post(".", "acquire_input_focus")
end

local function stop_moving(self)
	timer.cancel(self.move_handle)
	self.move_handle = nil
end

local function move_to(self, end_x, end_y)
    local world_pos = go.get_position()
    local start_x, start_y = tilemap.world_to_tile(world_pos.x, world_pos.y)
    local status, _, _, path = astar.solve(start_x, start_y, end_x, end_y)
    
	local function compare_paths(path1, path2)
		if #path1 ~= #path2 then
			return false
		end
		
		for i = 1, #path1 do
			if path1[i].x ~= path2[i].x or path1[i].y ~= path2[i].y then
				return false
			end
		end
		
		return true
	end

    -- Удаляем первую точку (текущую позицию)
    if path then 
		local path_x, path_y = tilemap.tile_to_world(path[1].x, path[1].y)
		if path_x == world_pos.x and path_y == world_pos.y then
			table.remove(path, 1)
		end

		if compare_paths(self.current_path, path) then
			return
		end
	end

    if status == astar.START_END_SAME or status == astar.NO_SOLUTION then
        print("Остановка")
        go.cancel_animations(".", "position")
        if self.move_handle then
            stop_moving(self)
        end
        self.is_moving = false
        go.set_position(self.position)  -- Фиксируем позицию
        return  -- Выходим, чтобы не продолжать движение
    end

    if status == astar.SOLVED then
        print("SOLVED")
        self.is_moving = true
        self.current_path = path
        
        if self.move_handle then 
            stop_moving(self)
        end

        local function move_step(self)
            if #self.current_path == 0 then
                print("stopped")
                self.is_moving = false
                if self.move_handle then
                    stop_moving(self)
                end
                return
            end
            
            local coord = self.current_path[1]
            local coord_x, coord_y = tilemap.tile_to_world(coord.x, coord.y)
            local target_pos = vmath.vector3(coord_x, coord_y, self.position.z)
            self.position = target_pos

            go.animate(".", "position", go.PLAYBACK_ONCE_FORWARD, target_pos, go.EASING_OUTSINE, 0.3, 0, function()
                table.remove(self.current_path, 1)
                print("moving to", coord_x, coord_y)
                
                if #self.current_path > 0 then
                    self.move_handle = timer.delay(0.1, false, function()
                        move_step(self)
                    end)
                else
                    self.is_moving = false
                end
            end)
        end

        move_step(self)
    end
end

function on_input(self, action_id, action)
	if self.is_target then
		local mouse_button_left = action_id == hash("mouse_button_left")
		if mouse_button_left and action.pressed then

			local world = vmath.screen_to_world(action.x, action.y, 0, camera.get_projection("/camera#camera"), camera.get_view("/camera#camera"))
			local tile_x, tile_y = tilemap.world_to_tile(world.x, world.y)

			-- Корректируем координаты, чтобы оставались в пределах карты
			tile_x = math.clamp(tile_x, 1, map_config.width)
			tile_y = math.clamp(tile_y, 1, map_config.height)

			move_to(self, tile_x, tile_y)
		end
	end
end

function on_message(self, message_id, message, sender)
	if message_id == hash("send_pawn_start_position") then
		go.set_position(vmath.vector3(message.x, message.y, self.start_position.z))
		self.position = self.start_position
	end
	if message_id == hash("set_target_pawn") then
		self.is_target = true
	end
end