go.property("start_position", vmath.vector3(1, 1, 0))

local map_config = require("game.tilemap.map_config")

local function set_target(self, is_target)
	self.is_target = is_target
	if self.is_target then
		go.set("#sprite", "tint", vmath.vector4(1,1,1,1))
	else
		go.set("#sprite", "tint", vmath.vector4(0.7,0.7,0.7,1))
	end
end

function init(self)
	self.position = vmath.vector3(0,0,0)
	self.is_target = false
	self.current_path = {}

	local spx, spy = tilemap.tile_to_world(self.start_position.x, self.start_position.y)
	go.set_position(vmath.vector3(spx, spy, self.start_position.z))
	msg.post(map_config.tilemap_path, "send_pawn", { x = self.start_position.x, y = self.start_position.y })

	table.insert(require("game.pawn.pawn_data").pawn_collection, { url = msg.url() })

	msg.post(".", "acquire_input_focus")

	set_target(self, false)
end

local function create_path(self, end_x, end_y)
	local world_pos = go.get_position()
	local start_x, start_y = tilemap.world_to_tile(world_pos.x, world_pos.y)
	local status, _, _, path = astar.solve(start_x, start_y, end_x, end_y)

	local function compare_paths(path1, path2)
		if #path1 ~= #path2 then
			return false
		end
		
		for i = 1, #path1 do
			if path1[i].x ~= path2[i].x or path1[i].y ~= path2[i].y then
				return false
			end
		end
		
		return true
	end

	-- Удаляем первую точку (текущую позицию)
	if path then 
		local path_x, path_y = tilemap.tile_to_world(path[1].x, path[1].y)
		if (path_x == world_pos.x and path_y == world_pos.y) then
			table.remove(path, 1)
		end

		if compare_paths(self.current_path, path) then
			return nil, status
		end
	end

	return path, status
end

local function move(self)
	local point_x, point_y = tilemap.tile_to_world(self.current_path[1].x, self.current_path[1].y)
	go.set_position(vmath.vector3(point_x, point_y, go.get_position().z))
	table.remove(self.current_path, 1)
	if #self.current_path == 0 then
		self.is_move = false
	end
end

local function move_to(self, x, y)
	local path, status = create_path(self, x, y)
	if path then
		self.current_path = path
	end

	if status == astar.SOLVED then
		self.is_move = true
	elseif status == astar.START_END_SAME then
		if #self.current_path > 0 then self.current_path = { x = self.current_path[1].x, y = self.current_path[1].y } end
	elseif status == astar.NO_SOLUTION then
		self.is_move = false
	end
end

function on_input(self, action_id, action)
	if self.is_target then
		local mouse_button_left = action_id == hash("mouse_button_left")
		if mouse_button_left and action.pressed then

			local world = vmath.screen_to_world(action.x, action.y, 0, camera.get_projection("/camera#camera"), camera.get_view("/camera#camera"))
			local tile_x, tile_y = tilemap.world_to_tile(world.x, world.y)

			-- Корректируем координаты, чтобы оставались в пределах карты
			tile_x = math.clamp(tile_x, 1, map_config.width)
			tile_y = math.clamp(tile_y, 1, map_config.height)
			
			move_to(self, tile_x, tile_y)
		end
	end
end

function on_message(self, message_id, message, sender)
	if message_id == hash("send_pawn_start_position") then
		go.set_position(vmath.vector3(message.x, message.y, self.start_position.z))
		self.position = self.start_position
	end
	if message_id == hash("set_target_pawn") then
		set_target(self, true)
	end
	if message_id == hash("tick") then
		if self.is_move then
			if #self.current_path > 0 then
				move(self)
			end
		end
	end
end