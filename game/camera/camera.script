
local game_events = require("management.game_events")
local global = require("management.global")

local BASE_WIDTH = sys.get_config_int("display.width")
local BASE_HEIGHT = sys.get_config_int("display.height")

local ZOOM_FACTOR = 1.1
local BASE_MAX_ZOOM = 10
local BASE_MIN_ZOOM = 2
local zoom

local camera_path = "#camera"


local function update_camera(self, width, height)
	local scale = math.min(width / BASE_WIDTH, height / BASE_HEIGHT)
	go.set(camera_path, "orthographic_zoom", zoom * scale)
	self.proj = camera.get_projection(camera_path)
	self.view = camera.get_view(camera_path)
end

function init(self)
	zoom = camera.get_orthographic_zoom(camera_path)
	msg.post(".", "acquire_input_focus")
	game_events.window_resized:subscribe(update_camera, self)	

	self.proj = camera.get_projection(camera_path)
	self.view = camera.get_view(camera_path)
end

function on_input(self, action_id, action)
	local mouse_wheel_up = action_id == hash("mouse_wheel_up")
	local mouse_wheel_down = action_id == hash("mouse_wheel_down")
	local drag_input = action_id == hash("mouse_button_middle") or action_id == hash("key_lctrl")
	
	if drag_input and action.pressed then
		self.start_cam_pos = go.get_position(go.get_id("/camera"))
		self.start_mouse_pos = vmath.vector3(action.x, action.y, 0)
		
		self.is_drag_cam = true
	end

	if self.is_drag_cam then
		local current_mouse_pos = vmath.vector3(action.x, action.y, 0)
		self.proj = camera.get_projection(camera_path)
		self.view = camera.get_view(camera_path)
		
		local start_world = global.screen_to_world(
			self.start_mouse_pos.x, 
			self.start_mouse_pos.y, 
			0,
			self.proj,
			self.view
		)

		local current_world = global.screen_to_world(
			current_mouse_pos.x, 
			current_mouse_pos.y, 
			0, 
			self.proj,
			self.view
		)

		local delta = current_world - start_world
		local new_pos = self.start_cam_pos - delta 
		go.set_position(new_pos, go.get_id("/camera"))
	end

	if drag_input and action.released then
		self.is_drag_cam = false
	end
	
	if mouse_wheel_up or mouse_wheel_down then
		local last_zoom = zoom
		if mouse_wheel_up then
			zoom = zoom * ZOOM_FACTOR
		elseif mouse_wheel_down then
			zoom = zoom / ZOOM_FACTOR
		end

		zoom = math.clamp(zoom, BASE_MIN_ZOOM, BASE_MAX_ZOOM)

		local width, height = window.get_size()
		local scale = math.min(width / BASE_WIDTH, height / BASE_HEIGHT)
		local cam_pos = go.get_position()

		-- Получаем позицию курсора в мировых координатах
		local mouse_x, mouse_y = action.x, action.y
		
		-- Конвертируем экранные координаты в мировые (до изменения зума)
		local world_x = cam_pos.x + (mouse_x - width/2) / (last_zoom * scale)
		local world_y = cam_pos.y + (mouse_y - height/2) / (last_zoom * scale)

		-- Вычисляем новую позицию камеры так, чтобы курсор остался на той же мировой позиции
		local new_pos_x = world_x - (mouse_x - width/2) / (zoom * scale)
		local new_pos_y = world_y - (mouse_y - height/2) / (zoom * scale)
		
		go.set_position(vmath.vector3(new_pos_x, new_pos_y, 0))
		go.set(camera_path, "orthographic_zoom", zoom * scale)
		--go.animate(camera_path, "orthographic_zoom", go.PLAYBACK_ONCE_FORWARD, zoom * scale, go.EASING_OUTQUAD, 0)
	end
end