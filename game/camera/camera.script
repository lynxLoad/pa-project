local BASE_WIDTH = sys.get_config_int("display.width")
local BASE_HEIGHT = sys.get_config_int("display.height")

-- Базовые значения зума (для исходного размера окна)
local BASE_MAX_ZOOM = 10
local BASE_MIN_ZOOM = 2
local BASE_ZOOM

local is_drag = false

local game_events = require("management.game_events")
local global = require("management.global")

local function update_camera(width, height)
	local scale = math.min(width / BASE_WIDTH, height / BASE_HEIGHT)
	-- Вычисляем актуальные MIN/MAX с учетом масштаба
	local current_min_zoom = BASE_MIN_ZOOM * scale
	local current_max_zoom = BASE_MAX_ZOOM * scale

	go.set("#camera", "orthographic_zoom", math.clamp(BASE_ZOOM * scale, current_min_zoom, current_max_zoom))
end

function init(self)
	global.screen_to_world(1, 1, 1, camera.get_projection("#camera"), camera.get_view("#camera"))
	BASE_ZOOM = camera.get_orthographic_zoom("#camera")
	msg.post(".", "acquire_input_focus")
	game_events.window_resized:subscribe(update_camera)
end

function on_input(self, action_id, action)
	local mouse_wheel_up = action_id == hash("mouse_wheel_up")
	local mouse_wheel_down = action_id == hash("mouse_wheel_down")
	local drag_input = action_id == hash("mouse_button_middle") or action_id == hash("key_lctrl")

	if action.x == 0 and action.y == 0 then
		return
	end
	
	if drag_input and action.pressed then
		self.start_cam_pos = go.get_position(go.get_id("/camera"))
		self.start_mouse_pos = vmath.vector3(
			action.x, 
			action.y, 
			0
		)
		
		is_drag = true
	end

	if is_drag then
		local current_mouse_pos = vmath.vector3(
			action.x, 
			action.y, 
			0
		)

		-- Преобразуем обе точки (начальную и текущую) в мировые координаты
		local start_world = global.screen_to_world(
			self.start_mouse_pos.x, 
			self.start_mouse_pos.y, 
			0,
			camera.get_projection("#camera"),
			camera.get_view("#camera")
		)

		local current_world = global.screen_to_world(
			current_mouse_pos.x, 
			current_mouse_pos.y, 
			0, 
			camera.get_projection("#camera"), 
			camera.get_view("#camera")
		)

		local delta = current_world - start_world
		local new_pos = self.start_cam_pos - delta 
		go.set_position(new_pos, go.get_id("/camera"))
	end

	if drag_input and action.released then
		is_drag = false
	end
	
	if mouse_wheel_up or mouse_wheel_down then
		BASE_ZOOM = camera.get_orthographic_zoom("#camera")
		local ZOOM_FACTOR = 1.5
		local next_zoom
		if mouse_wheel_up then
			next_zoom = BASE_ZOOM * ZOOM_FACTOR
		end
		if mouse_wheel_down then
			next_zoom = BASE_ZOOM / ZOOM_FACTOR
		end
		
		-- Получаем текущий размер окна
		local width, height = window.get_size()
		local scale = math.min(width / BASE_WIDTH, height / BASE_HEIGHT)
		-- Вычисляем актуальные MIN/MAX для проверки
		local current_min_zoom = BASE_MIN_ZOOM * scale
		local current_max_zoom = BASE_MAX_ZOOM * scale

		next_zoom = math.clamp(next_zoom, current_min_zoom, current_max_zoom)
		go.animate(
			"#camera",                     -- Идентификатор объекта камеры
			"orthographic_zoom",          -- Свойство для анимации
			go.PLAYBACK_ONCE_FORWARD,     -- Тип анимации (однократная)
			next_zoom,                  -- Конечное значение
			go.EASING_OUTQUAD,            -- Функция плавности (можно выбрать другую)
			0.2                          -- Длительность анимации (сек)
		)
	end
end