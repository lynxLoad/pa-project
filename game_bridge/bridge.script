-- bridge.script
go.property("start_position", vmath.vector3(1, 1, 0))
go.property("script_path", hash("game.pawn.pawn"))

local data = require("game.pawn.pawn")

-- Создаем wrapper для каждого экземпляра pawn
local wrapper = {
	hooks = {
		init = {},
		on_message = {},
		update = {},
		on_input = {}
	},
	register_hook = function(self, event, callback)
		if not self.hooks[event] then
			print("Warning: Unknown hook event " .. tostring(event))
			return
		end
		table.insert(self.hooks[event], callback)
	end,
	call_hooks = function(self, event, ...)
		if not self.hooks[event] then
			print("Warning: No hooks registered for " .. tostring(event))
			return
		end
		for _, callback in ipairs(self.hooks[event] or {}) do
			local ok, err = pcall(callback, ...)
			if not ok then
				print("Error in hook for " .. event .. ": " .. tostring(err))
			end
		end
	end
}

function init(self)
	-- Сохраняем wrapper и модуль в self.data
	self.data = data
	self.data._wrapper = wrapper

	-- Вызываем оригинальный init
	if self.data.init then
		self.data.init(self)
	end

	-- Регистрируем хуки из модуля
	if self.data.register_hooks then
		self.data.register_hooks(wrapper)
	end

	-- Вызываем хуки для init
	wrapper:call_hooks("init", self)
end

function on_input(self, action_id, action)
	if self.data.on_input then
		self.data.on_input(self, action_id, action)
	end
	self.data._wrapper:call_hooks("on_input", self, action_id, action)
end

function on_message(self, message_id, message, sender)
	if self.data.on_message then
		self.data.on_message(self, message_id, message, sender)
	end
	self.data._wrapper:call_hooks("on_message", self, message_id, message, sender)
end